package com.habibInc.issueTracker.project;

import com.habibInc.issueTracker.exceptionhandler.ApiError;
import com.habibInc.issueTracker.issue.Issue;
import com.habibInc.issueTracker.issue.IssueRepository;
import com.habibInc.issueTracker.security.JwtUtil;
import com.habibInc.issueTracker.user.User;
import com.habibInc.issueTracker.user.UserRepository;
import com.habibInc.issueTracker.user.UserService;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.*;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class ProjectIT {

    @Autowired
    TestRestTemplate restTemplate;

    @Autowired
    ProjectService projectService;

    @Autowired
    UserService userService;

    @Autowired
    ProjectRepository projectRepository;

    @Autowired
    IssueRepository issueRepository;

    @Autowired
    UserRepository userRepository;

    @Autowired
    JwtUtil jwtUtil;

    User authenticatedUser;
    String token;
    HttpHeaders headers;

    Project project, project2;

    @BeforeEach
    public void authSetup() {
        // create a user to authenticate
        authenticatedUser = new User();
        authenticatedUser.setEmail("auth.user@email.com");
        authenticatedUser.setPassword("auth_password");
        authenticatedUser.setFullName("auth full name");
        authenticatedUser.setUserName("auth username");

        // save the user to pass authorization
        authenticatedUser = userService.createUser(authenticatedUser);

        // generate an auth token signed with the user email
        token = jwtUtil.generateToken(authenticatedUser.getEmail());

        // set up the authorization header with the auth token
        headers = new HttpHeaders();
        headers.add(JwtUtil.HEADER, JwtUtil.TOKEN_PREFIX + token);
    }

    @BeforeEach
    public void setup() {
        project = new Project();
        project.setName("Primary project");

        project2 = new Project();
        project2.setName("Secondary project");
    }

    @Nested
    @DisplayName("POST")
    class Post {

        private final String baseUrl = "/projects";
        HttpEntity<Project> httpEntity;

        @BeforeEach
        public void setup() {
            httpEntity = new HttpEntity<>(project, headers);
        }

        @Test
        public void itShouldCreateProject() {
            // when a POST request to create a new project is made
            ResponseEntity<Project> response =
                    restTemplate.postForEntity(baseUrl, httpEntity, Project.class);

            // then expect the response to be the created project with an autogenerated id and the authenticated user set as owner
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
            assertThat(response.getBody().getId()).isNotNull().isPositive();
        }

        @Test
        public void givenCreateProject_itShouldSetAuthenticatedUserAsProjectOwner() {
            // given the POST request to create the project
            ResponseEntity<Project> response =
                    restTemplate.postForEntity(baseUrl, httpEntity, Project.class);

            // when the project is created
            Project createdProject =
                    projectService.getProjectById(response.getBody().getId());

            // then expect the authenticated user to have been set as project owner
            assertThat(createdProject.getOwner()).isEqualTo(authenticatedUser);
        }

        @Test
        public void itShouldAddUserToProject() {
            // given a user to add to the project
            User user = new User();
            user.setEmail("userToAdd@project");
            user.setPassword("user_project");
            user.setFullName("added user");
            user.setUserName("added_user");

            user = userService.createUser(user);

            // given the project
            project = projectService.createProject(project, authenticatedUser);

            // given the url endpoint
            String url = "/projects/" + project.getId() + "/users/" + user.getId();

            HttpEntity httpEntity = new HttpEntity<>(headers);

            // when a POST request is made to add the user to the project
            ResponseEntity<Void> response =
                    restTemplate.exchange(url, HttpMethod.POST, httpEntity, Void.class);

            // then expect the user to have been added to the project successfully
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

            // when a GET request is made to fetch the list of projects by user id
            ResponseEntity<Project[]> getResponse =
                    restTemplate.exchange("/projects?user=" + user.getId(), HttpMethod.GET, httpEntity, Project[].class);

            // then expect the project to have been added to the user's list of assigned projects
            assertThat(getResponse.getBody()).contains(project);
        }
    }

    @Nested
    @DisplayName("GET")
    class Get {

        private final String baseUrl = "/projects";
        HttpEntity<Project> httpEntity;

        @BeforeEach
        public void setup() {
            httpEntity = new HttpEntity<>(headers);
        }

        @Test
        public void itShouldGetProjectById() {
            // given the project is created
            project = projectService.createProject(project, authenticatedUser);

            // when a GET request to fetch the project by id is made
            ResponseEntity<Project> response = restTemplate.exchange(
                    baseUrl + "/" + project.getId(),
                    HttpMethod.GET,
                    httpEntity,
                    Project.class
            );

            // then the project should be retrieved successfully
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).isEqualToComparingOnlyGivenFields(project);
        }

        @Test
        public void givenGetProjectById_whenProjectDoesNotExist_itShouldReturnProjectNotFoundError() {
            // when the project does not exist
            ResponseEntity<ApiError> response = restTemplate.exchange(
                    baseUrl + "/404",
                    HttpMethod.GET,
                    httpEntity,
                    ApiError.class
            );

            // then expect a 404 project not found error
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
            assertThat(response.getBody().getErrorMessage()).contains("Project not found");
        }

        @Test
        public void itShouldGetListOfAllProjects() {
            // given a list of projects
            List<Project> projects = List.of(project, project2);
            projects = (List<Project>) projectRepository.saveAll(projects);

            // when a GET request to fetch all projects is made
            ResponseEntity<Project[]> response = restTemplate.exchange(
                    baseUrl,
                    HttpMethod.GET,
                    httpEntity,
                    Project[].class
            );

            // then expect the response to be the list of projects
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).hasSameElementsAs(projects);
        }

        @Test
        public void itShouldGetProjectBacklog() {
            // given the project is saved
            project = projectService.createProject(project, authenticatedUser);

            // given the GET backlog url
            String url = String.format("%s/%s/backlog", baseUrl, project.getId());

            // given the project backlog
            List<Issue> backlog = List.of(
                    Issue.builder().project(project).summary("issue 1").build(),
                    Issue.builder().project(project).summary("issue 2").build(),
                    Issue.builder().project(project).summary("issue 2").build()
            );

            // given the backlog is saved
            backlog = (List<Issue>) issueRepository.saveAll(backlog);

            // when a GET request to fetch the project backlog is made
            ResponseEntity<Issue[]> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    httpEntity,
                    Issue[].class
            );

            // then expect the backlog to have been retrieved successfully
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).hasSameElementsAs(backlog);
        }

        @Test
        public void givenGetProjectBacklog_itShouldNotFetchBacklogIssuesOfOtherProjects() {
            // given two distinct projects
            project = projectService.createProject(project, authenticatedUser);
            project2 = projectService.createProject(project2, authenticatedUser);

            // given the first project's backlog
            List<Issue> backlogPrimary = List.of(
                    Issue.builder().project(project).summary("issue 1").build(),
                    Issue.builder().project(project).summary("issue 2").build(),
                    Issue.builder().project(project).summary("issue 2").build()
            );

            // given the other project's backlog
            List<Issue> backlogSecondary = List.of(
                    Issue.builder().project(project2).summary("issue 3").build(),
                    Issue.builder().project(project2).summary("issue 4").build()
            );

            // given the backlogs are saved
            backlogPrimary = (List<Issue>) issueRepository.saveAll(backlogPrimary);
            backlogSecondary = (List<Issue>) issueRepository.saveAll(backlogSecondary);

            // given the GET backlog url
            String url = String.format("%s/%s/backlog", baseUrl, project.getId());

            // when a GET request to fetch a project's backlog is made
            ResponseEntity<Issue[]> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    httpEntity,
                    Issue[].class
            );

            // then expect the response to be the list of issues
            // belonging to that project's backlog only
            assertThat(response.getBody()).containsExactlyElementsOf(backlogPrimary);
            assertThat(response.getBody()).doesNotContainAnyElementsOf(backlogSecondary);
        }

        @Test
        public void itShouldGetProjectsByAssignedUser() {
            // given a user
            User user = new User();
            user.setEmail("assigned_user@email.com");
            user.setPassword("assigned_user_pass");
            user.setFullName("assigned user");
            user.setUserName("assigned_user");

            user = userService.createUser(user);

            // given a set of projects
            List<Project> projects = (List<Project>) projectRepository.saveAll(
                    List.of(
                            Project.builder().assignedUsers(Set.of(user)).name("Project 01").build(),
                            Project.builder().assignedUsers(Set.of(user)).name("Project 02").build(),
                            Project.builder().assignedUsers(Set.of(user)).name("Project 03").build()
                    )
            );

            // when a GET request is made to fetch the list of projects by assigned user id
            ResponseEntity<Project[]> response =
                    restTemplate.exchange("/projects?user=" + user.getId(), HttpMethod.GET, httpEntity, Project[].class);

            // then expect the projects to have been fetched successfully
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).containsExactlyElementsOf(projects);
        }
    }

    @Nested
    @DisplayName("DELETE")
    class Delete {

        HttpEntity httpEntity;

        @BeforeEach
        public void setup() {
            httpEntity = new HttpEntity(headers);
        }

        @Test
        public void itShouldRemoveUserFromProject() {
            // given a user
            User user = userService.createUser(
                    User.builder()
                            .userName("username")
                            .fullName("full name")
                            .email("user@email.me")
                            .password("user@pass")
                            .build()
            );

            // given the project
            project = projectService.createProject(project, authenticatedUser);

            // given the user is added to the project
            projectService.addUserToProject(user.getId(), project.getId());

            // expect the user to have been added successfully
            assertThat(userService.getUsersByAssignedProject(project.getId())).contains(user);

            // given the URL
            String url = "/projects/" + project.getId() + "/users/" + user.getId();

            // when a DELETE request is made to remove the user from the project
            ResponseEntity<Void> response =
                    restTemplate.exchange(url, HttpMethod.DELETE, httpEntity, Void.class);

            // then expect the user to have been removed successfully
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        }
    }

    @AfterEach
    public void teardown() {
        issueRepository.deleteAll();
        projectRepository.deleteAll();
        userRepository.deleteAll();
    }
}
